# -*- coding: utf-8 -*-
"""New Release Finder

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ENCVTDsJHH1HTMHHXiha125iUHOJcALX
"""

import requests
import base64
import time
from urllib.parse import urlencode

# --- Your Spotify API Credentials ---
# Replace these with the credentials from your Spotify Developer Dashboard App
CLIENT_ID = "CLIENT_ID"
CLIENT_SECRET = "CLIENT_SECRET"
# ------------------------------------

# --- Customize Your Search ---
# Add or remove genres to tailor your search for new releases.
GENRE_LIST = [
    "rock", "alt-rock", "indie", "punk", "hardcore",
    "metal", "death-metal", "black-metal", "deathcore",
    "hip-hop", "trap","rap",
    "pop", "synth-pop",
    "electronic", "techno", "house", "ambient",
    "jazz", "soul", "funk", "blues",
    "classical", "folk", "country", "metalcore"
]
# -----------------------------


def get_spotify_token(client_id, client_secret):
    """Gets an access token from the Spotify API."""
    auth_url = 'https://accounts.spotify.com/api/token'
    auth_header = base64.b64encode(f"{client_id}:{client_secret}".encode('utf-8')).decode('utf-8')
    headers = {'Authorization': f'Basic {auth_header}'}
    data = {'grant_type': 'client_credentials'}
    response = requests.post(auth_url, headers=headers, data=data)
    if response.status_code == 200:
        return response.json().get('access_token')
    else:
        print(f"Error getting token: {response.status_code} - {response.text}")
        return None

def search_new_releases_by_genre(token, genres):
    """Searches for new releases across a list of genres, correctly handling pagination."""
    all_new_releases = []
    seen_album_ids = set()

    headers = {'Authorization': f'Bearer {token}'}
    base_search_url = 'https://api.spotify.com/v1/search'

    for genre in genres:
        print(f"\nSearching for new releases in genre: '{genre}'...")

        # --- THE FIX IS IMPLEMENTED HERE ---

        # 1. Start with the base URL and the parameters for the first search.
        next_url = base_search_url
        params = {
            'q': f'genre:"{genre}" tag:new',
            'type': 'album',
            'limit': 50
        }

        # Loop to handle all pages of results for the current genre
        while next_url:
            # 2. Make the request using the URL and any available params.
            # The `requests` library correctly handles if `params` is None.
            response = requests.get(next_url, headers=headers, params=params)

            # 3. CRITICAL: Clear the params after the first request.
            # The 'next_url' from Spotify contains all needed parameters,
            # so we must not send them again.
            if params:
                params = None

            if response.status_code == 200:
                data = response.json()
                albums = data.get('albums', {}).get('items', [])

                found_count = 0
                for album in albums:
                    if album['id'] not in seen_album_ids:
                        all_new_releases.append(album)
                        seen_album_ids.add(album['id'])
                        found_count += 1

                if found_count > 0:
                    print(f"   > Found {found_count} new unique releases.")

                # Get the URL for the next page of results
                next_url = data.get('albums', {}).get('next')
                time.sleep(0.1)
            elif response.status_code == 429:
                retry_after = int(response.headers.get('Retry-After', 1))
                print(f"   > Rate limit hit. Waiting for {retry_after} seconds...")
                time.sleep(retry_after)
            else:
                print(f"   > Error searching for genre '{genre}': {response.status_code} - {response.text}")
                break # Stop searching this genre if an error occurs

    return all_new_releases

def display_releases(releases):
    """Prints the list of releases in a readable format."""
    if not releases:
        print("No releases found or an error occurred.")
        return

    print("\n\n--- ðŸŽ¸ A More Comprehensive List of New Releases ---")

    # Sort releases by release date, most recent first
    releases.sort(key=lambda x: x['release_date'], reverse=True)

    for i, item in enumerate(releases, 1):
        album_type = item['album_type'].capitalize()
        album_name = item['name']
        release_date = item['release_date']
        artist_names = ', '.join([artist['name'] for artist in item['artists']])
        spotify_url = item['external_urls']['spotify']

        print(f"\n{i}. [{album_type}] {artist_names} - {album_name}")
        print(f"   Released: {release_date}")
        print(f"   Listen here: {spotify_url}")

    print(f"\n--- Total Unique Releases Found: {len(releases)} ---")


if __name__ == "__main__":
    if CLIENT_ID == "YOUR_CLIENT_ID_HERE" or CLIENT_SECRET == "YOUR_CLIENT_SECRET_HERE":
        print("ðŸ›‘ ERROR: Please replace the placeholder credentials in the script.")
    else:
        access_token = get_spotify_token(CLIENT_ID, CLIENT_SECRET)
        if access_token:
            new_releases = search_new_releases_by_genre(access_token, GENRE_LIST)
            display_releases(new_releases)

